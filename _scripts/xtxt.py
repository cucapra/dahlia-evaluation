import re

class XTXTParser:
    """
    Parse .xtxt files generated by SDAccel's estimation.
    """

    def __init__(self, filepath):
        with open(filepath, 'r') as data:
            self.lines = data.read().split('\n')

    def parse_table(self, header, offset):
        """Parse a table. `header` should be a valid regex.
        The parsing begins at the location of `header` + `offset`.
        Tables should look like this


        Latency Information (clock cycles)   <-- `header`
        Compute Unit  Kernel Name  Module Name  Start Interval  Best Case  Avg Case  Worst Case
        ------------  -----------  -----------  --------------  ---------  --------  ----------
        gemm_1        gemm         gemm         139             138        138       138
                                             <-- empty line to mark the end
        """

        table_lines = self._get_table(header, offset)
        header_row = table_lines[0]
        dashes_row = table_lines[1]

        # Get the lengths of ---- in the second row to use with parsing. Simple
        # split on " " does not work because header names might have spaces
        # in their names.
        header_lens = [len(dashes) for dashes in dashes_row.split(' ') if dashes.strip() != '']

        # Parse the headers. Extract the exact number of character as there are
        # dashes underneath it.
        headers = []
        idx = 0
        for header_len in header_lens:
            headers.append(header_row[idx:idx + header_len].strip())
            idx = idx + header_len
            while idx < len(header_row) and header_row[idx] == ' ' :
                idx += 1

        # Start parsing the rows. Skip the headers row and the seperation row.
        row_idx = 2
        table = []
        for row in table_lines[row_idx:]:
            row_vals = [ val.strip() for val in row.split(' ') if val.strip() != '' ]
            assert len(row_vals) == len(headers), "Row vals has {} values. Expected {}.\n{}".format(len(row_vals), len(headers), row)

            table.append({ headers[i]: row_vals[i] for i in range(len(headers)) })

        return table

    def _get_table(self, header, offset):
        """Return a list containing the table to be parsed. The header are
        matched using the format describe in parse_table.
        """

        # Table can also end with ------------
        END_LINE = re.compile('^-+$')

        start = 0
        end = 0

        for idx, line in enumerate(self.lines, 0):
            if header.search(line):
                start = idx + offset
                end = start
                while(end < len(self.lines) and self.lines[end].strip() != '' and not END_LINE.search(self.lines[end])):
                    end += 1
                break

        assert end > start, "Failed to find table start with header {}".format(header)

        return self.lines[start:end]
