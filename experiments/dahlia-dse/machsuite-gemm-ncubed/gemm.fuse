decl m1_interface: double[64][64];
decl m2_interface: double[64][64];
decl prod_interface: double[64][64];

let m1: double{2}[64 bank ::M1_D1::][64 bank ::M1_D2::];
let m2: double{2}[64 bank ::M2_D1::][64 bank ::M2_D2::];
let prod: double{2}[64 bank ::PROD_D1::][64 bank ::PROD_D2::];

{
  view m1_v = m1[_: bank 1][_: bank 1];
  view m2_v = m2[_: bank 1][_: bank 1];
  // copy to fpga
  for (let i = 0..64) {
    for (let j = 0..64) {
      m1_v[i][j] := m1_interface[i][j];
      m2_v[i][j] := m2_interface[i][j];
    }
  }

  ---

  for (let i = 0..64) unroll ::UR_LOOP1:: {
    // pipeline ??
    for (let j = 0..64) unroll ::UR_LOOP2:: {
      let sum: double = 0.0;
      for (let k = 0..64) unroll ::UR_LOOP3:: {
        let mult = m1[i][k] * m2[k][j];
      } combine {
        sum += mult;
      }
      prod[i][j] := sum;
    }
  }

  // copy back
  ---
  view prod_v = prod[_: bank 1][_: bank 1];
  for (let i = 0..64) {
    for (let j = 0..64) {
      prod_interface[i][j] := prod_v[i][j];
    }
  }

}
