// inputs
decl nodes_edge_begin_interface: ubit<64>[256];
decl nodes_edge_end_interface: ubit<64 >[256];
decl edges_src_interface: ubit<64>[4096];
decl edges_dst_interface: ubit<64>[4096];

decl starting_node_fake: ubit<64>;
decl level_interface: bit<8>[256];

// output
decl level_counts_interface: ubit<64>[10];

// local memories
let nodes_edge_begin: ubit<64>{2}[256 bank ::NODES_EDGE_BEG::];
let nodes_edge_end: ubit<64>{2}[256 bank ::NODES_EDGE_END::];
let edges_src: ubit<64>{2}[4096 bank ::EDGES_SRC::];
let edges_dst: ubit<64>{2}[4096 bank ::EDGES_DST::];

let level: bit<8>{2}[256 bank ::LEVEL::];

// output
let level_counts: ubit<64>{2}[10 bank ::LEVEL_COUNTS::];

let queue: ubit<64>{2}[256 bank ::QUEUE_BANK::];
let MAX_LEVEL: bit<64> = 127;
let starting_node: ubit<64> = 38;

view nodes_edge_end_v = nodes_edge_end[_:bank 1];
view edges_src_v = edges_src[_: bank 1];
view edges_dst_v = edges_dst[_: bank 1];
view level_v = level[_: bank 1];
view level_counts_v = level_counts[_: bank 1];
view nodes_edge_begin_v = nodes_edge_begin[_: bank 1];
view queue_v = queue[_: bank 1];

{
  // copy over loop
  for (let i = 0..256) {
    nodes_edge_begin_v[i] := nodes_edge_begin_interface[i];
    nodes_edge_end_v[i] := nodes_edge_end_interface[i];
    level_v[i] := level_interface[i];
  }

  for (let i = 0..4096) {
    edges_src_v[i] := edges_src_interface[i];
    edges_dst_v[i] := edges_dst_interface[i];
  }
  ---
  level_v[starting_node] := 0;
  level_counts_v[0] := 1;
  // copy over loop

  let q_in: ubit<64> = 1;
  let q_out: ubit<64> = 0;

  if (q_in == 0) {
    queue_v[255] := starting_node;
  } else {
    queue_v[q_in - 1] := starting_node;
  }
  let temp_q_in = (q_in + 1) % 256;
  q_in := temp_q_in;
  ---

  for (let dummy = 0..256) unroll ::DUMMY_UR:: {
    decor "#pragma HLS loop_tripcount max=256 min=1"
    let q_empty: bool = false;
    if (q_in > q_out) {
      q_empty := (q_in == q_out + 1);
    } else {
      q_empty := (q_in == 0) && (q_out == 255);
    }

    if (q_empty) {
      dummy := 256;
    }

    let n = queue_v[q_out];
    q_out := (q_out + 1) % 256;
    let e = nodes_edge_begin[n];
    let tmp_end: ubit<64> = nodes_edge_end[n];
    ---

    while (e < tmp_end) {
      decor "#pragma HLS loop_tripcount avg=17"
      let tmp_dst: ubit<64> = edges_dst[e];
      let tmp_level: bit<8> = level[tmp_dst];
      ---

      if (tmp_level == MAX_LEVEL) {
        tmp_level := level[n] + 1;
        let tmp_level_counts = level_counts[tmp_level];
        ---

        level[tmp_dst] := tmp_level;
        level_counts[tmp_level] := tmp_level_counts + 1;

        if (q_in == 0) {
          queue[255] := tmp_dst;
        } else {
          queue[q_in - 1] := tmp_dst;
        }
        temp_q_in := (q_in + 1) % 256;
        q_in := temp_q_in;
      }
      e := e + 1;
    }
  }

  // copy back loop
  ---
  for (let i = 0..10) {
    level_counts_interface[i] := level_counts_v[i];
  }
  // copy back loop
}
