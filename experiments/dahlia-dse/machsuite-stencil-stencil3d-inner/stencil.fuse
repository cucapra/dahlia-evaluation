decl C: bit<32>[2];
decl orig: bit<32>{2}[32 bank 2][32 bank 2][16 bank 2];
decl sol: bit<32>{2}[32 bank 2][32 bank 2][16 bank 2];

// Handle boundary conditions by filling with original values
view orig_nb = orig[_: bank 1][_: bank 1][_: bank 1];
view orig_v0 = orig[_: bank 1][_:][_:];
view orig_v1 = orig[_:][_: bank 1][_:];
view orig_v2 = orig[_:][_:][_: bank 1];
{
  for (let j = 0..32) unroll 2 {
    for (let k = 0..16) unroll 2 {
      sol[0][j][k] := orig_v0[0][j][k];
      ---
      sol[31][j][k] := orig_v0[31][j][k];
    }
  }

  ---

  for (let i = 1..31) unroll 2 {
    for (let k = 0..16) unroll 2 {
      sol[i][0][k] := orig_v1[i][0][k];
      ---
      sol[i][31][k] := orig_v1[i][31][k];
    }
  }
  ---

  for (let i = 1..31) unroll 2 {
    for (let j = 1..31) unroll 2 {
      sol[i][j][0] := orig_v2[i][j][0];
      ---
      sol[i][j][15] := orig_v2[i][j][15];
    }
  }
// it is wired that we cannot bank this...
// Stencil computation
  ---
  for (let i = 0..30) {
    for (let j = 0..30) {
      for (let k = 0..14) {
        let temp1: bit<32> = orig_nb[i][j][k] * C[0];
        ---
        for (let m = 0..2) unroll 2 {
          view orig_v3 = orig[2*m: bank 2][_:][_:];
          let mul: bit<32> = orig_v3[i][j][k] * C[1];
        }
      }
    }
  }
}
