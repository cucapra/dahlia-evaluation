record ivector_t {
  x: bit<32>;
  y: bit<32>;
  z: bit<32>
}

record dvector_t {
  x: double;
  y: double;
  z: double
}

decor "#pragma SDS data copy(n_points[0:64])"

decl n_points_interface: bit<32>[4][4][4];
decl force_x_interface: double[4][4][4][10];
decl force_y_interface: double[4][4][4][10];
decl force_z_interface: double[4][4][4][10];
decl position_x_interface: double[4][4][4][10];
decl position_y_interface: double[4][4][4][10];
decl position_z_interface: double[4][4][4][10];

// local memories
let n_points: bit<32>[4 bank ::N_POINTS_D1::][4 bank ::N_POINTS_D2::][4 bank ::N_POINTS_D3::];
let position_x: double{2}[4 bank ::POS_D1::][4 bank ::POS_D2::][4 bank ::POS_D3::][10 bank ::POS_D4::];
let position_y: double{2}[4 bank ::POS_D1::][4 bank ::POS_D2::][4 bank ::POS_D3::][10 bank ::POS_D4::];
let position_z: double{2}[4 bank ::POS_D1::][4 bank ::POS_D2::][4 bank ::POS_D3::][10 bank ::POS_D4::];

view n_points_v = n_points[_:bank 1][_:bank 1][_:bank 1];
view position_x_v = position_x[_:][_:][_:][_:bank 1];
view position_y_v = position_y[_:][_:][_:][_:bank 1];
view position_z_v = position_z[_:][_:][_:][_:bank 1];
view position_x_v1 = position_x[_:bank 1][_:bank 1][_:bank 1][_:bank 1];
view position_y_v1 = position_y[_:bank 1][_:bank 1][_:bank 1][_:bank 1];
view position_z_v1 = position_z[_:bank 1][_:bank 1][_:bank 1][_:bank 1];

view n_points_copy_v = n_points[_:bank 1][_:bank 1][_:bank 1];
view position_x_copy_v = position_x[_:bank 1][_:bank 1][_:bank 1][_:bank 1];
view position_y_copy_v = position_y[_:bank 1][_:bank 1][_:bank 1][_:bank 1];
view position_z_copy_v = position_z[_:bank 1][_:bank 1][_:bank 1][_:bank 1];

let force_local: dvector_t[4 bank ::FORCE_LOCAL_D1::][4 bank ::FORCE_LOCAL_D2::][4 bank ::FORCE_LOCAL_D3::][10 bank ::FORCE_LOCAL_D4::];
view force_local_v = force_local[_:][_:][_:][_:bank 1];
view force_local_v1 = force_local[_:bank 1][_:bank 1][_:bank 1][_:bank 1];
{
  // copy over loop
  for (let a = 0..4) {
    for (let b = 0..4) {
      for (let c = 0..4) {
        n_points_copy_v[a][b][c] := n_points_interface[a][b][c];
        for (let d = 0..10) {
          position_x_copy_v[a][b][c][d] := position_x_interface[a][b][c][d];
          position_y_copy_v[a][b][c][d] := position_y_interface[a][b][c][d];
          position_z_copy_v[a][b][c][d] := position_z_interface[a][b][c][d];
        }
      }
    }
  }
  ---
  // copy over loop

  let empty: dvector_t = {x = 0.0; y = 0.0; z = 0.0};

  for (let b0x = 0..4) unroll ::FORCE_LOCAL_X_UR:: {
    for (let b0y = 0..4) unroll ::FORCE_LOCAL_Y_UR::  {
      for (let b0z = 0..4) unroll ::FORCE_LOCAL_Z_UR::  {
        for (let p_idx = 0..10) unroll ::FORCE_LOCAL_P_UR:: {
          force_local[b0x][b0y][b0z][p_idx] := empty;
        }
      }
    }
  }
  ---
  for(let b0x = 0..4) unroll ::B0X_UR:: {
    for(let b0y = 0..4) unroll ::B0Y_UR:: {
      for(let b0z = 0..4) unroll ::B0Z_UR:: {
        let b1min: ivector_t = {x = 0; y = 0; z = 0};
        let b1max: ivector_t = {x = 4; y = 4; z = 4};
        if((b0x - 1) > b1min.x){
          let newbmin : ivector_t = {x = b0x - 1; y = b1min.y; z = b1min.z};
          b1min := newbmin;
        }
        if((b0y - 1) > b1min.y){
          let newbmin : ivector_t = {x = b1min.x; y = b0y - 1; z = b1min.z};
          b1min := newbmin;
        }
        if((b0z - 1) > b1min.z){
          let newbmin : ivector_t = {x = b1min.x; y = b1min.y; z = b0z -1};
          b1min := newbmin;
        }
        if((b0x + 2) < b1max.x){
          let newbmax : ivector_t = {x = b0x + 2; y = b1max.y; z = b1max.z};
          b1max := newbmax;
        }
        if((b0y + 2) < b1max.y){
          let newbmax : ivector_t = {x = b1max.x; y = b0y + 2; z = b1max.z};
          b1max := newbmax;
        }
        if((b0z + 2) < b1max.z){
          let newbmax : ivector_t = {x = b1max.x; y = b1max.y; z = b0z + 2};
          b1max := newbmax;
        }
        ---
        let b1x:bit<32> = b1min.x;
        while (b1x < b1max.x) {
          decor "#pragma HLS loop_tripcount max=2 min=0"
          let b1y:bit<32> = b1min.y;
          while (b1y < b1max.y) {
            decor "#pragma HLS loop_tripcount max=2 min=0"
            let b1z:bit<32> = b1min.z;
            while (b1z < b1max.z) {
              decor "#pragma HLS loop_tripcount max=2 min=0"
              let q_idx_range = n_points_v[b1x][b1y][b1z];
              ---
              let p_idx:bit<32> = 0;
              let p_idx_upper = n_points[b0x][b0y][b0z];
              while(p_idx < p_idx_upper){
                decor "#pragma HLS loop_tripcount avg=3"
                let p: dvector_t = {x = position_x_v[b0x][b0y][b0z][p_idx]; y = position_y_v[b0x][b0y][b0z][p_idx]; z = position_z_v[b0x][b0y][b0z][p_idx]};
                ---
                let sum_x = force_local_v[b0x][b0y][b0z][p_idx].x;
                let sum_y = force_local_v[b0x][b0y][b0z][p_idx].y;
                let sum_z = force_local_v[b0x][b0y][b0z][p_idx].z;
                let q_idx:bit<32> = 0;
                while(q_idx < q_idx_range){
                  decor "#pragma HLS loop_tripcount avg=3"
                  let q: dvector_t = {x = position_x_v1[b1x][b1y][b1z][q_idx]; y = position_y_v1[b1x][b1y][b1z][q_idx]; z = position_z_v1[b1x][b1y][b1z][q_idx]};
                  if ((q.x != p.x) || (q.y != p.y) || (q.z != p.z)){
                    // Compute the LJ-potential
                    let dx = p.x - q.x;
                    let dy = p.y - q.y;
                    let dz = p.z - q.z;
                    let r2inv = 1.0 / (dx*dx + dy*dy + dz*dz);
                    let r6inv = r2inv*r2inv*r2inv;
                    let potential = r6inv*(1.5*r6inv - 2.0);
                    // Update forces
                    let f = r2inv*potential;
                    sum_x := sum_x + (f*dx);
                    sum_y := sum_y + (f*dy);
                    sum_z := sum_z + (f*dz);
                  }
                  q_idx := q_idx + 1;
                } // loop_q
                ---
                let newforcelocal : dvector_t = {x = sum_x; y = sum_y; z = sum_z};
                force_local_v[b0x][b0y][b0z][p_idx] := newforcelocal;
                p_idx := p_idx + 1;
              } // loop_p
              b1z := b1z + 1;
            }
            b1y := b1y + 1;
          }
          b1x := b1x + 1;
        } // loop_grid1_*
  }}} // loop_grid0_*
  ---

  // copy back loop
  for (let a = 0..4) {
    for (let b = 0..4) {
      for (let c = 0..4) {
        for (let d = 0..10) {
          force_x_interface[a][b][c][d] := force_local_v1[a][b][c][d].x;
          force_y_interface[a][b][c][d] := force_local_v1[a][b][c][d].y;
          force_z_interface[a][b][c][d] := force_local_v1[a][b][c][d].z;
        }
      }
    }
  }
  // copy back loop
}
