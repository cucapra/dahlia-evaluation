// input
decl nodes_edge_begin_interface: ubit<64>[256];
decl nodes_edge_end_interface: ubit<64>[256];
decl edges_src_interface: ubit<64>[4096];
decl edges_dst_interface: ubit<64>[4096];
decl starting_node: ubit<64>;
decl level_interface: bit<8>[256];

// output
decl level_counts_interface: ubit<64>[10];

// local memories
let nodes_edge_begin: ubit<64>{2}[256 bank ::NODES_EDGE_BEG::];
let nodes_edge_end: ubit<64>{2}[256 bank ::NODES_EDGE_END::];
let edges_src: ubit<64>{2}[4096 bank ::EDGES_SRC::];
let edges_dst: ubit<64>{2}[4096 bank ::EDGES_DST::];
let level: bit<8>{2}[256 bank ::LEVEL::];
let level_counts: ubit<64>{2}[10 bank ::LEVEL_COUNTS::];

{
  view nodes_edge_begin_v = nodes_edge_begin[_: bank 1];
  view nodes_edge_end_v = nodes_edge_end[_: bank 1];
  view edges_src_v = edges_src[_: bank 1];
  view edges_dst_v = edges_dst[_: bank 1];
  view level_v = level[_: bank 1];

  // copy over loops
  for (let i = 0..256) {
    nodes_edge_begin_v[i] := nodes_edge_begin_interface[i];
    nodes_edge_end_v[i] := nodes_edge_end_interface[i];
    level_v[i] := level_interface[i];
  }

  for (let i = 0..4096) {
    edges_src_v[i] := edges_src_interface[i];
    edges_dst_v[i] := edges_dst_interface[i];
  }
  // copy over loops

  let MAX_LEVEL: bit<8> = 127;

  level[starting_node] := 0;
  level_counts[0] := 1;
  ---

  for (let horizon = 0..10) unroll ::HORIZON_UR:: {
    decor "#pragma HLS loop_tripcount max=10 min=1"
    let cnt:ubit<64> = 0;
    for (let n = 0..256) unroll ::N_UR:: {
      let tmp_l = level[n];
      ---
      if (tmp_l == horizon) {
        let e = nodes_edge_begin[n];
        ---
        let tmp_end = nodes_edge_end[n];
        ---
        while (e < tmp_end) {
          decor "#pragma HLS loop_tripcount avg=17"
          let tmp_dst = edges_dst[e];
          let tmp_level = level[tmp_dst];
          ---
          if (tmp_level == MAX_LEVEL) {
            level[tmp_dst] := horizon + 1;
            ---
            cnt := cnt + 1;
          }
          e := e + 1;
        }
      }
    }
    level_counts[horizon + 1] := cnt;
    if (cnt == 0) {
      horizon := 10;
    }
  }

  // copy back loop
  view level_counts_v = level_counts[_: bank 1];
  for (let i = 0..10) {
    level_counts_interface[i] := level_counts_v[i];
  }
  // copy back loop

}
