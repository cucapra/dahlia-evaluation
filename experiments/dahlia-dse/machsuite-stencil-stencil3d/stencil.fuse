decl C: bit<32>[2];
decl orig: bit<32>{2}[32 bank 2][32 bank 2][16 bank 2];
decl sol: bit<32>{2}[32 bank 2][32 bank 2][16 bank 2];

// Handle boundary conditions by filling with original values
view orig_v0  = orig[_: bank 1][_:][_:];
{
  for (let j = 0..32) unroll 2 {
    for (let k = 0..16) unroll 2 {
      sol[0][j][k] := orig_v0[0][j][k];
      ---
      sol[31][j][k] := orig_v0[31][j][k];
    }
  }

  ---

  for (let i = 1..31) unroll 2 {
    for (let k = 0..16) unroll 2 {
      sol[i][0][k] := orig_v0[i][0][k];
      ---
      sol[i][31][k] := orig_v0[i][31][k];
    }
  }
  ---

  for (let i = 1..31) unroll 2 {
    for (let j = 1..31) unroll 2 {
      sol[i][j][0] := orig_v0[i][j][0];
      ---
      sol[i][j][15] := orig_v0[i][j][15];
    }
  }
}
---
// it is wired that we cannot bank this...
// Stencil computation
view orig_v1 = orig[1!:][_:][_:];

for (let i = 1..31) unroll 2 {
  for (let j = 1..31) unroll 2 {
    for (let k = 1..15) unroll 2 {
      let temp1 = orig[i][j][k] * C[0];
      ---
      let temp2 = orig_v1[i][j][k] * C[1] + temp1;
    }
  }
}
