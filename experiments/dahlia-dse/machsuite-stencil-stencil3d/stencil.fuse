decl C: bit<32>[2];
decl orig: bit<32>{2}[32 bank 2][32 bank 2][16 bank 2];
decl sol: bit<32>{2}[32 bank 2][32 bank 2][16 bank 2];

// Handle boundary conditions by filling with original values
view orig_v0  = orig[_: bank 1][_:][_:];
{
  for (let j = 0..32) unroll 2 {
    for (let k = 0..16) unroll 2 {
      sol[0][j][k] := orig_v0[0][j][k];
      ---
      sol[31][j][k] := orig_v0[31][j][k];
    }
  }

  ---

  for (let i = 1..31) unroll 2 {
    for (let k = 0..16) unroll 2 {
      sol[i][0][k] := orig_v0[i][0][k];
      ---
      sol[i][31][k] := orig_v0[i][31][k];
    }
  }
  ---

  for (let i = 1..31) unroll 2 {
    for (let j = 1..31) unroll 2 {
      sol[i][j][0] := orig_v0[i][j][0];
      ---
      sol[i][j][15] := orig_v0[i][j][15];
    }
  }
}
---
// it is wired that we cannot bank this...
// Stencil computation
for (let i = 1..31) unroll 2 {
  for (let j = 1..31) unroll 2 {
    for (let k = 1..15) unroll 2 {
      let temp1 = orig[i][j][k] * C[0];
      ---
      let temp2 = orig[i + 1][j][k] * C[1] + temp1;
      ---
      let temp3 = orig[i - 1][j][k] * C[1] + temp2;
      ---
      let temp4 = orig[i][j + 1][k] * C[1] + temp3;
      ---
      let temp5 = orig[i][j - 1][k] * C[1] + temp4;
      ---
      let temp6 = orig[i][j][k + 1] * C[1] + temp5;
      ---
      sol[i][j][k] := orig[i][j][k - 1] * C[1] + temp6;
    }
  }
}
