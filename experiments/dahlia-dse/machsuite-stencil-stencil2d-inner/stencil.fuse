decl orig_interface: bit<32>[128][64];
decl filter_interface: bit<32>[3][3];
decl sol_interface: bit<32>[128][64];

let orig: bit<32>{2}[129 bank ::ORIG_D1::][66 bank ::ORIG_D2::];
let filter: bit<32>{2}[3 bank ::FILTER_D1::][3 bank ::FILTER_D2::];
let sol: bit<32>{2}[128][64];

view orig_v = orig[_: bank 1][_: bank 1];
view filter_v = filter[_: bank 1][_: bank 1];
view sol_v = sol[_: bank 1][_: bank 1];
{
  for (let i = 0..128){
    for (let j = 0..64){
      orig_v[i][j] := orig_interface[i][j];
    }
  }
  ---
  for (let j = 64..66){
    orig_v[128][j] := 0;
  }

  for (let i = 0..3){
    for (let j = 0..3){
      filter_v[i][j] := filter_interface[i][j];
    }
  }
  ---
  for (let r = 0..126) {
    for (let c = 0..62) {
      view orig_v2 = orig[r!: bank ::ORIG_SH1::][c!: bank ::ORIG_SH2::];
      view filter_sh = filter[_: bank ::FILTER_SH1::][_: bank ::FILTER_SH2::];
      let temp: bit<32> = 0;
      for (let k1 = 0..3) unroll ::UR_LOOP1:: {
        let temp_2: bit<32> = 0;
        for (let k2 = 0..3) unroll ::UR_LOOP2:: {
          let mul = filter[k1][k2] * orig_v2[k1][k2];
        } combine {
          temp_2 += mul;
        }
      } combine {
        temp += temp_2;
      }
      sol[r][c] := temp;
    }
  }
  ---

  for (let i = 0..126){
    for (let j = 0..62){
      sol_interface[i][j] := sol_v[i][j];
    }
  }


}
