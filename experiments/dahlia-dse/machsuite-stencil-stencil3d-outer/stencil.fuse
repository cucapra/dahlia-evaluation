decl C_interface: bit<32>[2];
decl orig_interface: bit<32>[32][32][16];
decl sol_interface: bit<32>[32][32][16];

let C: bit<32>{2}[2];
let orig: bit<32>{2}[32 bank ::ORIG_D1::][32 bank ::ORIG_D2::][16 bank ::ORIG_D3::];
let sol: bit<32>{2}[32 bank ::SOL_D1::][32 bank ::SOL_D2::][16 bank ::SOL_D3::];

view orig_v = orig[_: bank 1][_: bank 1][_:bank 1];
view sol_v = sol[_: bank 1][_: bank 1][_:bank 1];
view C_v = C[_: bank 1];
{
  for (let i = 0..2){
    C_v[i] := C_interface[i];
  }
  ---
  for (let i = 0..32){
    for (let j = 0..32){
      for (let k = 0..16){
        orig_v[i][j][k] := orig_interface[i][j][k];
      }
    }
  }

  ---
  // Stencil computation
  view orig_u1 = orig[-1!: bank ::ORIG_SH1::][_  : bank ::ORIG_SH2::][_  : bank ::ORIG_SH3::];
  view orig_u2 = orig[1! : bank ::ORIG_SH1::][_  : bank ::ORIG_SH2::][_  : bank ::ORIG_SH3::];
  view orig_u3 = orig[_  : bank ::ORIG_SH1::][-1!: bank ::ORIG_SH2::][_  : bank ::ORIG_SH3::];
  view orig_u4 = orig[_  : bank ::ORIG_SH1::][1! : bank ::ORIG_SH2::][_  : bank ::ORIG_SH3::];
  view orig_u5 = orig[_  : bank ::ORIG_SH1::][_  : bank ::ORIG_SH2::][-1!: bank ::ORIG_SH3::];
  view orig_u6 = orig[_  : bank ::ORIG_SH1::][_  : bank ::ORIG_SH2::][1! : bank ::ORIG_SH3::];

  view sol_sh = sol[_: bank ::SOL_SH1::][_: bank ::SOL_SH2::][_: bank ::SOL_SH3::];

  for (let i = 0..32) unroll ::UR_LOOP1:: {
    for (let j = 0..32) unroll ::UR_LOOP2:: {
      for (let k = 0..16) unroll ::UR_LOOP3:: {
        let temp1 = orig[i][j][k] * C[0];
        ---
        let temp2 = orig_u1[i][j][k] * C[1] + temp1;
        ---
        let temp3 = orig_u2[i][j][k] * C[1] + temp2;
        ---
        let temp4 = orig_u3[i][j][k] * C[1] + temp3;
        ---
        let temp5 = orig_u4[i][j][k] * C[1] + temp4;
        ---
        let temp6 = orig_u5[i][j][k] * C[1] + temp5;
        ---
        sol[i][j][k] := orig_u6[i][j][k] * C[1] + temp6;
      }
    }
  }
  ---
  // Handle boundary conditions by filling with original values
  view orig_v0 = orig[_: bank 1][_: bank ::ORIG_SH2:: ][_: bank ::ORIG_SH3:: ];
  view sol_v0 = sol[_: bank 1][_: bank ::SOL_SH2:: ][_: bank ::SOL_SH2:: ];
  for (let j = 0..32) unroll ::UR_LOOP2:: {
    for (let k = 0..16) unroll ::UR_LOOP3:: {
      sol_v0[0][j][k] := orig_v0[0][j][k];
      ---
      sol_v0[31][j][k] := orig_v0[31][j][k];
    }
  }

  ---

  view orig_v1 = orig[_: bank ::ORIG_SH1::][_: bank 1][_: bank ::ORIG_SH3::];
  view sol_v1 = sol[_: bank ::SOL_SH1::][_: bank 1][_: bank ::SOL_SH3::];
  for (let i = 0..32) unroll ::UR_LOOP1:: {
    for (let k = 0..16) unroll ::UR_LOOP3:: {
      sol_v1[i][0][k] := orig_v1[i][0][k];
      ---
      sol_v1[i][31][k] := orig_v1[i][31][k];
    }
  }
  ---
  view orig_v2 = orig[_: bank ::ORIG_SH1:: ][_: bank ::ORIG_SH2:: ][_: bank 1];
  view sol_v2 = sol[_: bank ::SOL_SH1:: ][_:  bank ::SOL_SH2:: ][_: bank 1];
  for (let i = 0..32) unroll ::UR_LOOP1:: {
    for (let j = 0..32) unroll ::UR_LOOP2:: {
      sol_v2[i][j][0] := orig_v2[i][j][0];
      ---
      sol_v2[i][j][15] := orig_v2[i][j][15];
    }
  }
  ---
  for (let i = 0..32) {
    for (let j = 0..32) {
      for (let k = 0..16) {
        sol_interface[i][j][k] := sol_v[i][j][k];
      }
    }
  }
}
