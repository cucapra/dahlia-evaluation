record edge_t {
  dst: ubit<64>
}

record node_t {
  edge_begin: ubit<64>;
  edge_end: ubit<64>
}

decor "#pragma SDS data copy(nodes[0:N_NODES])"
decor "#pragma SDS data zero_copy(level[0:N_NODES])"

decl nodes: node_t[50];
decl edges: edge_t[50];
decl starting_node: ubit<64>;
decl level: bit<8>[50];
decl level_counts: ubit<64>[50];

let cnt = 0;

// Temporary variables for serial updates
let tmp_begin:ubit<64> = 0;
let tmp_end:ubit<64>   = 0;
let tmp_dst:ubit<64>   = 0;
let tmp_level:bit<8> = 0;

let MAX_LEVEL = 10;

let tmp_l:bit<32> = 0;

for (let horizon = 0..50) {
  cnt := 0;
  for (let n = 0..50) {
    tmp_l := level[n];
    ---
    if (tmp_l == horizon) {
      tmp_begin := nodes[n].edge_begin;
      ---
      tmp_end := nodes[n].edge_end;
      ---
      for (let e = 0..50) { // FIXME: find upper bound
        decor "#pragma HLS loop_tripcount avg=12"
        if (e >= tmp_begin && e <= tmp_end) {
          tmp_dst := edges[e].dst;
          tmp_level := level[tmp_dst];
          ---
          if (tmp_level == MAX_LEVEL) {
            level[tmp_dst] := horizon + 1;
            ---
            cnt := cnt + 1;
          }
        }
      }
    }
  }
}
