// ALEN: 128
// BLEN: 128

decor "#pragma SDS data copy(SEQA[0:ALEN])"
decor "#pragma SDS data zero_copy(M[0:16641], ptr[0:16641])"

decl SEQA: bit<8>[128];
decl SEQB: bit<8>[128];
decl alignedA: bit<8>[256];
decl alignedB: bit<8>[256];
decl M: bit<32>[16641];
decl ptr: bit<8>[16641];

let MATCH_SCORE    = 1;
let MISMATCH_SCORE = 0-1; // -1
let GAP_SCORE      = 0-1; // -1
let ALIGN      = 92; // ASCII for '\\'
let SKIPA      = 94; // ASCII for '^'
let SKIPB      = 60; // ASCII for '<'
let DASH       = 45; // ASCII for '-'
let UNDERSCORE = 95; // ASCII for '_'

let score:bit<32>   = 0;
let up_left:bit<32> = 0;
let up:bit<32>      = 0;
let left:bit<32>    = 0;
let max:bit<32>     = 0;
let row:bit<32>     = 0;
let row_up:bit<32>  = 0;
let r:bit<32>       = 0;

for (let a_idx = 0..129) {
  decor "#pragma HLS loop_tripcount max=100 min=0"
  M[a_idx] := a_idx * GAP_SCORE;
}

---

for (let b_idx = 0..129) {
  decor "#pragma HLS loop_tripcount max=100 min=0"
  M[b_idx*129] := b_idx * GAP_SCORE;
}

---

for (let b_idx = 1..129) {
  decor "#pragma HLS loop_tripcount max=100 min=0"
  for (let a_idx = 1..129) {
    decor "#pragma HLS loop_tripcount max=100 min=0"
    if (SEQA[a_idx-1] == SEQB[b_idx-1]) {
      score := MATCH_SCORE;
    } else {
      score := MISMATCH_SCORE;
    }

    row_up := (b_idx-1) * 129;
    row    := (b_idx) * 129;

    up_left := M[row_up + a_idx-1] + score;
    ---
    up      := M[row_up + a_idx  ] + GAP_SCORE;
    ---
    left    := M[row    + a_idx-1] + GAP_SCORE;

    if (up_left >= up && up_left >= left) {
      max := up_left;
    } else {
      if (up >= left) {
        max := up;
      } else {
        max := left;
      }
    }
    ---
    M[row + a_idx] := max;
    if (max == left) {
      ptr[row + a_idx] := SKIPB;
    } else {
      if (max == up) {
        ptr[row + a_idx] := SKIPA;
      } else {
        ptr[row + a_idx] := ALIGN;
      }
    }
  }
}
---
let a_idx = 128; // ALEN
let b_idx = 128; // BLEN
let a_str_idx:bit<32> = 0;
let b_str_idx:bit<32> = 0;

while (a_idx>0 || b_idx>0) {
  decor "#pragma HLS loop_tripcount max=100 min=0"
  r := b_idx * 129;

  if (ptr[r + a_idx] == ALIGN) {
    alignedA[a_str_idx] := SEQA[a_idx-1];
    alignedB[b_str_idx] := SEQB[b_idx-1];
    a_idx := a_idx - 1;
    b_idx := b_idx - 1;
  } else {
    if (ptr[r + a_idx] == SKIPB) {
      alignedA[a_str_idx] := SEQA[a_idx-1];
      alignedB[b_str_idx] := DASH;
      a_idx := a_idx - 1;
    } else {
      alignedA[a_str_idx] := DASH;
      alignedB[b_str_idx] := SEQB[b_idx-1];
      b_idx := b_idx - 1;
    }
  }
  a_str_idx := a_str_idx + 1;
  b_str_idx := b_str_idx + 1;
}
---
while (a_str_idx < 256) {
  decor "#pragma HLS loop_tripcount max=100 min=0"
  alignedA[a_str_idx] := UNDERSCORE;
  a_str_idx := a_str_idx + 1;
}

while (b_str_idx < 256) {
  decor "#pragma HLS loop_tripcount max=100 min=0"
  alignedB[b_str_idx] := UNDERSCORE;
  b_str_idx := b_str_idx + 1;
}
