def local_scan(bucket: bit<32>[128 bank 2][16]) {
  let bucket_tmp1: bit<32> = 0;
  let bucket_tmp2: bit<32> = 0;
  for (let radix_id = 0..128) unroll 2 {
    for (let i = 1..16) {
      bucket_tmp1 := bucket[radix_id][i - 1];
      ---
      bucket_tmp2 := bucket[radix_id][i];
      ---
      bucket[radix_id][i] := bucket_tmp1 + bucket_tmp2;
    }
  }
}

def sum_scan(sum: bit<32>[128 bank 2], bucket: bit<32>[128 bank 2][16]) {
  let sum_tmp: bit<32> = 0;
  sum[0] := 0;
  ---
  view sumshift = sum[1!:];
  for (let radix_id = 0..128) unroll 2 {  // HACK wasted: upper bound is 127.
    sum_tmp := sum[radix_id];
    ---
    sumshift[radix_id] := sum_tmp + bucket[radix_id][15];
  }
}

def last_step_scan(bucket: bit<32>[128 bank 2][16], sum: bit<32>[128 bank 2]) {
  let bucket_tmp: bit<32> = 0;
  for (let radix_id = 0..128) unroll 2 {
    for (let i = 0..16) {
      bucket_tmp := bucket[radix_id][i];
      ---
      bucket[radix_id][i] := bucket_tmp + sum[radix_id];
    }
  }
}

def init(bucket: bit<32>[128 bank 2][16]) {
  for (let i = 0..128) unroll 2 {
    for (let j = 0..16) {
      bucket[i][j] := 0;
    }
  }
}

def hist(bucket: bit<32>[128 bank 2][16], a: bit<32>[512][4], exp: bit<32>) {
  let bucket_idx: bit<32> = 0;
  let bucket_tmp: bit<32> = 0;
  view bucketv = bucket[_: bank 1][_: bank 1];
  for (let block_id = 0..512) {
    for (let i = 0..4) {
      bucket_idx := ((a[block_id][i] >> exp) & 0x3) * 512 + block_id + 1;
      bucket_tmp := bucketv[bucket_idx / 16][bucket_idx % 16];
      ---
      bucketv[bucket_idx / 16][bucket_idx % 16] := bucket_tmp + 1;
    }
  }
}

def update(b: bit<32>[512][4], bucket: bit<32>[128 bank 2][16], a: bit<32>[512][4], exp: bit<32>) {

  let bucket_idx: bit<32> = 0;
  let elem_per_block: bit<32> = 4;
  let a_idx: bit<32> = 0;

  let bucket_tmp: bit<32> = 0;

  view bucketv = bucket[_: bank 1][_: bank 1];
  for (let block_id = 0..512) {
    for (let i = 0..4) {
      bucket_idx := ((a[block_id][i] >> exp) & 0x3) * 512 + block_id;
      bucket_tmp := bucketv[bucket_idx / 16][bucket_idx % 16];
      ---
      b[bucket_tmp / 4][bucket_tmp % 4] := a[block_id][i];
      bucketv[bucket_idx / 16][bucket_idx % 16] := bucket_tmp + 1;
    }
  }
}

decor "#pragma SDS data zero_copy(a[0:512][0:4], b[0:512][0:4], bucket[0:128][0:16], sum[0:128])"

decl a: bit<32>[512][4];
decl b: bit<32>[512][4];
decl bucket: bit<32>[128 bank 2][16];
decl sum: bit<32>[128 bank 2];

let valid_buffer = 0;
let buffer_a = 0;
let buffer_b = 1;
let temp_valid_buffer = 0;

for (let exp = 0..16) {
  init(bucket);
  
  ---
  if (valid_buffer == buffer_a) {
    hist(bucket, a, exp << 1);
  } else {
    hist(bucket, b, exp << 1);
  }
  
  ---
  local_scan(bucket);
  ---
  sum_scan(sum, bucket);
  ---
  last_step_scan(bucket, sum);

  ---
  if (valid_buffer == buffer_a) {
    update(b, bucket, a, exp << 1);
    temp_valid_buffer := buffer_b;
  } else {
    update(a, bucket, b, exp << 1);
    temp_valid_buffer := buffer_a;
  }

  ---
  valid_buffer := temp_valid_buffer;
}
