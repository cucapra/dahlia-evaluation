def at_j(pos: double[256 bank 8], j: bit<32>): double {
  view v = pos[j!:];
  return v[0];
}

decl force_x: double[256 bank 8];
decl force_y: double[256 bank 8];
decl force_z: double[256 bank 8];
decl position_x: double[256 bank 8];
decl position_y: double[256 bank 8];
decl position_z: double[256 bank 8];
decl nl: bit<32>[256 bank 8][16];

let lj1:double = 1.5;
let lj2:double = 2.0;

for (let i = 0..256) unroll 8 {
  let ix = position_x[i];
  let iy = position_y[i];
  let iz = position_z[i];
  ---

  let fx: double = 0.0;
  let fy: double = 0.0;
  let fz: double = 0.0;

  for (let j = 0..16) {
    let j_idx = nl[i][j];

    let jx = at_j(position_x, j);
    let jy = at_j(position_y, j);
    let jz = at_j(position_z, j);

    let delx = ix - jx;
    let dely = iy - jy;
    let delz = iz - jz;

    let r2inv = 1.0 / (delx * delx + dely * dely + delz * delz);
    let r6inv = r2inv * r2inv * r2inv;
    let potential = r6inv * (lj1 * r6inv - lj2);

    let force = r2inv * potential;
  } combine {
    fx += delx * force;
    fy += dely * force;
    fz += delz * force;
  }

  force_x[i] := fx;
  force_y[i] := fy;
  force_z[i] := fz;
}
