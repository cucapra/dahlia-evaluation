// ALEN: 128
// BLEN: 128

decor "#pragma SDS data copy(SEQA[0:128])"
decor "#pragma SDS data zero_copy(M[0:16641], ptr[0:16641])"

decl SEQA: bit<8>[128 bank 2];
decl SEQB: bit<8>[128 bank 2];
decl alignedA: bit<8>[256];
decl alignedB: bit<8>[256];
decl M: bit<32>[130 bank 2][130 bank 2];  // HACK: Wasted space. (129.)
decl ptr: bit<8>[130 bank 2][130 bank 2];  // Ditto.

let MATCH_SCORE:bit<32>    = 1;
let MISMATCH_SCORE:bit<32> = 0-1; // -1
let GAP_SCORE:bit<32>      = 0-1; // -1
let ALIGN:bit<8>      = 92; // ASCII for '\\'
let SKIPA:bit<8>      = 94; // ASCII for '^'
let SKIPB:bit<8>      = 60; // ASCII for '<'
let DASH:bit<8>       = 45; // ASCII for '-'
let UNDERSCORE:bit<8> = 95; // ASCII for '_'

for (let a_idx = 0..130) unroll 2 {
  decor "#pragma HLS loop_tripcount avg=128"
  M[0][a_idx] := a_idx * GAP_SCORE;
}

---

for (let b_idx = 0..130) unroll 2 {
  decor "#pragma HLS loop_tripcount avg=128"
  M[b_idx][0] := b_idx * GAP_SCORE;
}

---

view ashift = SEQA[1*-1!:];
view bshift = SEQB[1*-1!:];
view mshift0 = M[-1!:][-1!:];
view mshift1 = M[-1!:][0!:];
view mshift2 = M[0!:][1*-1!:];
for (let b_idx = 1..129) unroll 2 {
  decor "#pragma HLS loop_tripcount avg=128"
  for (let a_idx = 1..129) unroll 2 {
    decor "#pragma HLS loop_tripcount avg=128"
    let score:bit<32>   = 0;
    if (ashift[a_idx] == bshift[b_idx]) {
      score := MATCH_SCORE;
    } else {
      score := MISMATCH_SCORE;
    }

    let up_left:bit<32> = mshift0[b_idx][a_idx] + score;
    ---
    let up:bit<32>      = mshift1[b_idx][a_idx] + GAP_SCORE;
    ---
    let left:bit<32>    = mshift2[b_idx][a_idx] + GAP_SCORE;

    let max:bit<32>     = 0;
    if (up_left >= up && up_left >= left) {
      max := up_left;
    } else {
      if (up >= left) {
        max := up;
      } else {
        max := left;
      }
    }
    ---
    M[b_idx][a_idx] := max;
    if (max == left) {
      ptr[b_idx][a_idx] := SKIPB;
    } else {
      if (max == up) {
        ptr[b_idx][a_idx] := SKIPA;
      } else {
        ptr[b_idx][a_idx] := ALIGN;
      }
    }
  }
}
---
let a_idx:bit<32> = 128; // ALEN
let b_idx:bit<32> = 128; // BLEN
let a_str_idx:bit<32> = 0;
let b_str_idx:bit<32> = 0;

view ptr_s = ptr[_: bank 1][_: bank 1];
view SEQA_s = SEQA[_: bank 1];
view SEQB_s = SEQB[_: bank 1];
while (a_idx>0 || b_idx>0) {
  decor "#pragma HLS loop_tripcount avg=151"
  let r:bit<32> = b_idx * 129;

  if (ptr_s[b_idx][a_idx] == ALIGN) {
    alignedA[a_str_idx] := SEQA_s[a_idx-1];
    alignedB[b_str_idx] := SEQB_s[b_idx-1];
    a_idx := a_idx - 1;
    b_idx := b_idx - 1;
  } else {
    if (ptr_s[b_idx][a_idx] == SKIPB) {
      alignedA[a_str_idx] := SEQA_s[a_idx-1];
      alignedB[b_str_idx] := DASH;
      a_idx := a_idx - 1;
    } else {
      alignedA[a_str_idx] := DASH;
      alignedB[b_str_idx] := SEQB_s[b_idx-1];
      b_idx := b_idx - 1;
    }
  }
  a_str_idx := a_str_idx + 1;
  b_str_idx := b_str_idx + 1;
}
---
while (a_str_idx < 256) {
  decor "#pragma HLS loop_tripcount avg=105"
  alignedA[a_str_idx] := UNDERSCORE;
  a_str_idx := a_str_idx + 1;
}

while (b_str_idx < 256) {
  decor "#pragma HLS loop_tripcount avg=105"
  alignedB[b_str_idx] := UNDERSCORE;
  b_str_idx := b_str_idx + 1;
}
